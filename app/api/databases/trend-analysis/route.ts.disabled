import { NextRequest, NextResponse } from 'next/server';
import { getUser } from '@/lib/supabase/server';
import { checkUserCredits, deductCredits, saveAnalysis, updateAnalysis } from '@/lib/utils/analysis';
import { dataForSeoClient } from '@/lib/dataforseo/client';

export async function POST(request: NextRequest) {
  try {
    const user = await getUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { keyword, domain, metric, date_from, date_to, location_code, language_code } = body;

    if (!keyword || !domain || !date_from || !date_to) {
      return NextResponse.json({ error: 'Keyword, Domain und Datumsbereich sind erforderlich' }, { status: 400 });
    }

    // Credits prüfen (3 Credits für Trend Analysis)
    const hasCredits = await checkUserCredits(user.id, 3);
    if (!hasCredits) {
      return NextResponse.json({ error: 'Nicht genügend Credits verfügbar' }, { status: 402 });
    }

    // Analysis-Eintrag erstellen
    const analysisId = await saveAnalysis(
      {
        keyword,
        domain,
        metric: metric || 'position',
        date_from,
        date_to,
        location_code: parseInt(location_code),
        language_code
      },
      'databases_serp_history',
      user.id,
      undefined,
      1
    );

    try {
      // DataForSEO Databases API aufrufen
      const response = await dataForSeoClient.dataforseo as any).trendAnalysisLive([
        {
          keyword,
          domain,
          metric: metric || 'position',
          date_from,
          date_to,
          location_code: parseInt(location_code),
          language_code
        } as any
      ]);

      if (!response || !response.results || response.results.length === 0) {
        throw new Error('Keine Trend Analysis Daten erhalten');
      }

      const result = response.results[0];
      
      // Ergebnisse verarbeiten
      const dataPoints = result.items?.map((item: any, index: number) => ({
        date: item.date || '',
        value: item[metric] || 0,
        change: index > 0 ? (item[metric] || 0) - (result.items[index - 1][metric] || 0) : 0,
        change_percentage: index > 0 && result.items[index - 1][metric] ? 
          ((item[metric] || 0) - (result.items[index - 1][metric] || 0)) / (result.items[index - 1][metric] || 1) * 100 : 0
      })) || [];

      // Trend-Analyse
      const values = dataPoints.map(p => p.value);
      const changes = dataPoints.map(p => p.change);
      
      const avgChange = changes.length > 0 ? changes.reduce((a, b) => a + b, 0) / changes.length : 0;
      const totalChange = values.length > 1 ? values[values.length - 1] - values[0] : 0;
      
      let trendDirection: 'up' | 'down' | 'stable' = 'stable';
      if (Math.abs(avgChange) > 0.1) {
        trendDirection = avgChange > 0 ? 'up' : 'down';
      }
      
      const trendStrength = Math.abs(avgChange) > 2 ? 'strong' : Math.abs(avgChange) > 0.5 ? 'moderate' : 'weak';
      const trendConfidence = Math.min(0.95, 0.5 + Math.abs(avgChange) * 0.1);

      // Insights generieren
      const insights: any[] = [];
      const volatility = values.length > 1 ? Math.sqrt(values.reduce((acc, val, i) => {
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        return acc + Math.pow(val - mean, 2);
      }, 0) / values.length) : 0;

      // Peaks und Valleys erkennen
      for (let i = 1; i < values.length - 1; i++) {
        if (values[i] > values[i-1] && values[i] > values[i+1]) {
          insights.push({
            type: 'peak',
            date: dataPoints[i].date,
            description: `Peak bei ${values[i].toFixed(1)}`,
            impact: values[i] > Math.max(...values) * 0.8 ? 'high' : 'medium'
          });
        } else if (values[i] < values[i-1] && values[i] < values[i+1]) {
          insights.push({
            type: 'valley',
            date: dataPoints[i].date,
            description: `Tiefpunkt bei ${values[i].toFixed(1)}`,
            impact: values[i] < Math.min(...values) * 1.2 ? 'high' : 'medium'
          });
        }
      }

      // Saisonalität berechnen (vereinfacht)
      const seasonalityScore = Math.min(1, volatility / (values.length > 0 ? Math.max(...values) : 1));

      // Vorhersagen (vereinfacht)
      const predictions = [];
      const lastValue = values[values.length - 1];
      const lastChange = changes[changes.length - 1];
      
      for (let i = 1; i <= 3; i++) {
        const futureDate = new Date(date_to);
        futureDate.setDate(futureDate.getDate() + i * 7); // Wöchentliche Vorhersagen
        
        predictions.push({
          date: futureDate.toISOString().split('T')[0],
          predicted_value: lastValue + (lastChange * i),
          confidence: Math.max(0.3, 0.9 - (i * 0.2))
        });
      }

      const processedResult = {
        keyword,
        domain,
        metric: metric || 'position',
        date_range: {
          start: date_from,
          end: date_to
        },
        trend_direction: trendDirection,
        trend_strength: trendStrength,
        trend_confidence: trendConfidence,
        data_points: dataPoints,
        insights: insights.slice(0, 10), // Limit für Performance
        predictions,
        summary: {
          total_change: totalChange,
          avg_change: avgChange,
          volatility,
          seasonality_score: seasonalityScore
        }
      };

      // Credits abziehen
      await deductCredits(user.id, 3);

      // Analysis updaten
      await updateAnalysis(analysisId, {
        status: 'completed',
        result: processedResult
      });

      return NextResponse.json({
        success: true,
        analysis_id: analysisId,
        result: processedResult
      });

    } catch (error) {
      console.error('DataForSEO API Error:', error);
      
      // Analysis als fehlgeschlagen markieren
      await updateAnalysis(analysisId, {
        status: 'failed',
        result: { error: error instanceof Error ? error.message : 'Unbekannter Fehler' }
      });

      return NextResponse.json({ 
        error: 'Fehler bei der Trend Analysis',
        details: error instanceof Error ? error.message : 'Unbekannter Fehler'
      }, { status: 500 });
    }

  } catch (error) {
    console.error('Trend Analysis API Error:', error);
    return NextResponse.json({ 
      error: 'Interner Serverfehler',
      details: error instanceof Error ? error.message : 'Unbekannter Fehler'
    }, { status: 500 });
  }
}
