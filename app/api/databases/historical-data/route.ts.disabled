import { NextRequest, NextResponse } from 'next/server';
import { getUser } from '@/lib/supabase/server';
import { checkUserCredits, deductCredits, saveAnalysis, updateAnalysis } from '@/lib/utils/analysis';
import { dataForSeoClient } from '@/lib/dataforseo/client';

export async function POST(request: NextRequest) {
  try {
    const user = await getUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { keyword, domain, date_from, date_to, location_code, language_code } = body;

    if (!keyword || !domain || !date_from || !date_to) {
      return NextResponse.json({ error: 'Keyword, Domain und Datumsbereich sind erforderlich' }, { status: 400 });
    }

    // Credits pr端fen (2 Credits f端r Historical Data)
    const hasCredits = await checkUserCredits(user.id, 2);
    if (!hasCredits) {
      return NextResponse.json({ error: 'Nicht gen端gend Credits verf端gbar' }, { status: 402 });
    }

    // Analysis-Eintrag erstellen
    const analysisId = await saveAnalysis(
      {
        keyword,
        domain,
        date_from,
        date_to,
        location_code: parseInt(location_code),
        language_code
      },
      'databases_keyword_history',
      user.id,
      undefined,
      1
    );

    try {
      // DataForSEO Databases API aufrufen
      const response = await dataForSeoClient.dataforseo as any).historicalDataLive([
        {
          keyword,
          domain,
          date_from,
          date_to,
          location_code: parseInt(location_code),
          language_code
        } as any
      ]);

      if (!response || !response.results || response.results.length === 0) {
        throw new Error('Keine Historical Data erhalten');
      }

      const result = response.results[0];
      
      // Ergebnisse verarbeiten
      const dataPoints = result.items?.map((item: any) => ({
        date: item.date || '',
        keyword: item.keyword || keyword,
        position: item.position || 0,
        search_volume: item.search_volume || 0,
        cpc: item.cpc || 0,
        difficulty: item.difficulty || 0,
        url: item.url || '',
        serp_features: item.serp_features || []
      })) || [];

      // Summary berechnen
      const positions = dataPoints.map(p => p.position).filter(p => p > 0);
      const searchVolumes = dataPoints.map(p => p.search_volume);
      
      const summary = {
        avg_position: positions.length > 0 ? positions.reduce((a, b) => a + b, 0) / positions.length : 0,
        position_change: positions.length > 1 ? positions[positions.length - 1] - positions[0] : 0,
        best_position: positions.length > 0 ? Math.min(...positions) : 0,
        worst_position: positions.length > 0 ? Math.max(...positions) : 0,
        avg_search_volume: searchVolumes.length > 0 ? searchVolumes.reduce((a, b) => a + b, 0) / searchVolumes.length : 0,
        total_impressions: searchVolumes.reduce((a, b) => a + b, 0)
      };

      const processedResult = {
        keyword,
        domain,
        date_range: {
          start: date_from,
          end: date_to
        },
        total_data_points: dataPoints.length,
        data_points: dataPoints,
        summary
      };

      // Credits abziehen
      await deductCredits(user.id, 2);

      // Analysis updaten
      await updateAnalysis(analysisId, {
        status: 'completed',
        result: processedResult
      });

      return NextResponse.json({
        success: true,
        analysis_id: analysisId,
        result: processedResult
      });

    } catch (error) {
      console.error('DataForSEO API Error:', error);
      
      // Analysis als fehlgeschlagen markieren
      await updateAnalysis(analysisId, {
        status: 'failed',
        result: { error: error instanceof Error ? error.message : 'Unbekannter Fehler' }
      });

      return NextResponse.json({ 
        error: 'Fehler bei der Historical Data Analyse',
        details: error instanceof Error ? error.message : 'Unbekannter Fehler'
      }, { status: 500 });
    }

  } catch (error) {
    console.error('Historical Data API Error:', error);
    return NextResponse.json({ 
      error: 'Interner Serverfehler',
      details: error instanceof Error ? error.message : 'Unbekannter Fehler'
    }, { status: 500 });
  }
}
