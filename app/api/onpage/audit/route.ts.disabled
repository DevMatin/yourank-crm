import { NextRequest, NextResponse } from 'next/server';
import { getUser } from '@/lib/supabase/server';
import { checkUserCredits, deductCredits, saveAnalysis, updateAnalysis } from '@/lib/utils/analysis';
import { dataForSeoClient } from '@/lib/dataforseo/client';
import { createTask } from '@/lib/utils/task-handler';

export async function POST(request: NextRequest) {
  try {
    const user = await getUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { target, max_crawl_pages, crawl_delay, enable_javascript, enable_redirects } = body;

    if (!target) {
      return NextResponse.json({ error: 'Target URL ist erforderlich' }, { status: 400 });
    }

    // Credits prüfen (3 Credits für OnPage Audit)
    const hasCredits = await checkUserCredits(user.id, 3);
    if (!hasCredits) {
      return NextResponse.json({ error: 'Nicht genügend Credits verfügbar' }, { status: 402 });
    }

    // Analysis-Eintrag erstellen
    const analysisId = await saveAnalysis(
      {
        target,
        max_crawl_pages: parseInt(max_crawl_pages),
        crawl_delay: parseInt(crawl_delay),
        enable_javascript: enable_javascript || false,
        enable_redirects: enable_redirects !== false
      },
      'onpage_audit',
      user.id,
      undefined,
      2
    );

    try {
      // DataForSEO OnPage API aufrufen (Task-basiert)
      const taskId = await createTask('onpage', 'task_post', [
        {
          target,
          max_crawl_pages: parseInt(max_crawl_pages),
          crawl_delay: parseInt(crawl_delay),
          enable_javascript: enable_javascript || false,
          enable_redirects: enable_redirects !== false,
          enable_browser_rendering: enable_javascript || false,
          custom_user_agent: 'YouRank SEO Audit Bot',
          accept_language: 'de-DE,de;q=0.9,en;q=0.8',
          store_raw_html: false,
          store_raw_screenshot: false
        }
      ]);

      // Analysis mit Task-ID updaten
      await updateAnalysis(analysisId, {
        status: 'pending',
        task_id: taskId
      });

      // Credits abziehen
      await deductCredits(user.id, 3);

      return NextResponse.json({
        success: true,
        analysis_id: analysisId,
        task_id: taskId,
        message: 'OnPage Audit gestartet. Die Analyse läuft im Hintergrund.'
      });

    } catch (error) {
      console.error('DataForSEO API Error:', error);
      
      // Analysis als fehlgeschlagen markieren
      await updateAnalysis(analysisId, {
        status: 'failed',
        result: { error: error instanceof Error ? error.message : 'Unbekannter Fehler' }
      });

      return NextResponse.json({ 
        error: 'Fehler beim Starten der OnPage Audit Analyse',
        details: error instanceof Error ? error.message : 'Unbekannter Fehler'
      }, { status: 500 });
    }

  } catch (error) {
    console.error('OnPage Audit API Error:', error);
    return NextResponse.json({ 
      error: 'Interner Serverfehler',
      details: error instanceof Error ? error.message : 'Unbekannter Fehler'
    }, { status: 500 });
  }
}

// Task-Ergebnis verarbeiten (wird vom Task-Handler aufgerufen)
async function processTaskResult(taskId: string, taskResult: any, analysisId: string) {
  try {
    if (!taskResult || !taskResult.results || taskResult.results.length === 0) {
      throw new Error('Keine OnPage Audit Daten erhalten');
    }

    const result = taskResult.results[0];
    
    // Issues verarbeiten
    const issues: any[] = [];
    let errors = 0;
    let warnings = 0;
    let infos = 0;

    if (result.items) {
      result.items.forEach((item: any) => {
        if (item.issues) {
          item.issues.forEach((issue: any) => {
            const severity = issue.severity || 'info';
            if (severity === 'error') errors++;
            else if (severity === 'warning') warnings++;
            else infos++;

            issues.push({
              type: issue.type || 'unknown',
              severity: severity,
              message: issue.message || '',
              url: item.url || '',
              line: issue.line || 0,
              column: issue.column || 0,
              description: issue.description || '',
              recommendation: issue.recommendation || ''
            });
          });
        }
      });
    }

    // Summary berechnen
    const summary = {
      title_issues: issues.filter(i => i.type.includes('title')).length,
      meta_description_issues: issues.filter(i => i.type.includes('meta_description')).length,
      heading_issues: issues.filter(i => i.type.includes('heading')).length,
      image_issues: issues.filter(i => i.type.includes('image')).length,
      internal_link_issues: issues.filter(i => i.type.includes('internal_link')).length,
      external_link_issues: issues.filter(i => i.type.includes('external_link')).length,
      technical_issues: issues.filter(i => i.type.includes('technical')).length
    };

    const processedResult = {
      total_pages: result.total_pages || 0,
      crawled_pages: result.crawled_pages || 0,
      issues_count: issues.length,
      errors,
      warnings,
      infos,
      issues: issues.slice(0, 1000), // Limit für Performance
      summary
    };

    // Analysis updaten
    await updateAnalysis(analysisId, {
      status: 'completed',
      result: processedResult
    });

    return processedResult;

  } catch (error) {
    console.error('OnPage Audit Task Processing Error:', error);
    
    await updateAnalysis(analysisId, {
      status: 'failed',
      error: error instanceof Error ? error.message : 'Fehler beim Verarbeiten der Ergebnisse'
    });

    throw error;
  }
}
